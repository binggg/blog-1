## 谈谈前端路由
  在前端开发的过程中，路由常常是一个常见的功能。今天就让我们来聊聊前端路由，本文将从前端路由介绍讲起，到浏览器路由 API 的讲解，最后分析一下 vue-router 的基本原理。这篇文章主要包含以下几部分的内容。 
  1. 前端路由介绍 
  2. 浏览器路由 API - history
  3. 浏览器路由 API - hash
  4. vue-router 路由基本原理
  5. 两种路由方式的异同点


### 前端路由介绍
  在早期的前后端尚未分离的时候，前端的路由一般是由后端控制，当前端点击 a 链接跳转的时候，会将对应的路径请求发送到后端，后端通过将路由和对应的页面模板进行匹配，返回一整个页面给浏览器，浏览器拿到页面后执行刷新操作，从而实现访问不同的地址得到不同页面的逻辑。随着 AJAX(异步数据更新) 技术的出现，浏览器不需要刷新整个页面就能更新 dom了，前端便开始逐渐开始主导路由的控制。


### 浏览器前端路由 API - History
 History 是 HTML5 新增的浏览器全局 API,  该接口允许用户操作浏览器的曾经在标签页或者框架里访问的会话历史记录。History 对象主要有以下的几个方法，同时 HTML5 也新增了一个 popstate 的全局事件，这个事件会在当活动历史记录更改的时候触发。

- History.back()  
前往上一页, 相当于用户点击了浏览器左上角的返回按钮. 也等价于 history.go(-1)。

- History.forward()  
在浏览器历史记录里前往下一页，相当于用户点击了浏览器左上角的前进按钮. 等价于 history.go(1).

 - History.go()  
 通过当前页面的相对位置从浏览器历史记录( 会话记录 )加载页面。比如：参数为-1的时候为上一页，参数为1的时候为下一页. 当整数参数超出界限时，该操作无效果，当传 0 的时候相当于刷新页面。

 - History.pushState()  
 该方法用于在历史中添加一条记录，其使用方式为:

 ```javascript
 history.pushState(state, title, url)
 // 其中三个参数的意义分别为
 state: object // 一个与被添加的记录关联的对象。在 popstate 事件中可以得到对应的 state 对象的副本
 title: string // 新页面的标题。但是，现在所有浏览器都忽视这个参数
 url: string // 新的网址，必须与当前页面处在同一个域(否则会失败报错),浏览器的地址栏将显示这个网址。
 ```
 执行该语句后，会往 histroy 对象里面添加一条新的记录，浏览器地址栏将显示新的地址，但是并不会加载新的文档，甚至不会检查该地址是否存在。

 - history.replaceState()
 该方法和 pushState 类似，不同的是， replaceState 修改 History 对象的当前记录。


 - popstate 事件  
这个事件是一个全局事件，每当同一个文档的浏览历史（即history对象）出现变化时，就会触发popstate事件，但是仅仅调用pushState()方法或replaceState()方法 ，并不会触发该事件，只有用户点击浏览器倒退按钮和前进按钮，或者使用 JavaScript 调用History.back()、History.forward()、History.go()方法时才会触发。

其使用方式如下:
```javascript
window.addEventListener('popstate',function() {
    console.log('history change')
    console.log(event.state) // 打印当前记录的 state 对象
});
history.pushState({state: 1}, '', '/foo')
history.pushState({state: 2}, '', '/bar')
history.pushState({state: 3}, '', '/test') // 当前记录为 '/test', state = {state: 3}

history.back() // 回退，当前记录为 '/bar' 所以打印结果为: history change {state: 2}
history.back() // 回退，当前记录为 '/foo' 所以打印结果为: history change {state: 1}
history.back() // 回退当初始页面，初始页面的 state 为 undefined, 所以打印结果为 history undefined
```
利用 History API 和 popstate 事件，结合 AJAX, 我们可以实现在不刷新页面的情况下切换路由和更新页面。 

### 浏览器路由 API - hash
所谓 hash, 即是字符串URL 的锚部分, 比如一个地址链接为 http://www.example.com/#/page1, 那么气 hash 值为 location.hash = '#/page1'。以 hash 作为路由一个好处是，hash 值部分的内容不会提交到服务，也就如果只改变 hash 部分，那么浏览器不会发送新的请求，且该 hash 记录会被添加到浏览器的访问历史记录中。例如：   

```javascript
// 假设当前路径为 www.example.com
location.hash = 'page1' // 路径变为 www.example.com/#page1
location.hash = 'page2' // 路径变为 www.example.com/#page2
location.hash = 'page3' // 路径变为 www.example.com/#page3

history.length // 4， 上述的操作改变了访问的历史记录， 所以也会触发 popstate 事件
history.back() // 路径变为 www.example.com/#page2
history.back() // 路径变为 www.example.com/#page1
history.forward() // 路径变为 www.example.com/#page2
```
另外 hash 值也常常作为定位到页面某个元素的锚点。

 - hashchange 事件  
hashchange 事件是 HTML5 新增的事件，当 url 处的哈希值改变的时候，便会触发此事件。例如:  
```javascript
window.addEventListener('hashchange',function() {
  console.log(location.href)
  console.log('hash change')
});
// 假设当前路径为 www.example.com
location.hash = 'page1' //  www.example.com/#page1 hash change
location.hash = 'page2' //  www.example.com/#page1 hash change
history.pushState(null, null, '/bar') // www.example.com/bar, 不会触发 hashchange
```
hash 改变不会触发浏览器的请求的表现似乎天然适合前端路由，结合 AJAX 技术，前端可以完全的控制前端路由，但是 hash 这种路由控制的方式不利于搜索引擎。

### vue-router 路由基本原理
用过 vue-router 的同学都知道， vue-router 可以设置两个路由模式，分别是 history 和 hash。同时 vue-router 的文档中也有编程式 router.push()， router.replace()，router.go() 看起来是不是和上面的 history 类似的呢？所以我们有理由认为 vue-router 的实现应该是和 HTML5 history 和 location.hash 有着某种联系，下面就让我们一起来看看 vue-router 的内部到底做了什么, 下面的 demo 基于 vue-cli

- vue-router 的使用方式
1. 首先是定义路由规则，即是每个路由对应的组件
```javascript
// router/index.js
import Vue from 'vue'
import Router from 'vue-router'
import index from '@/components/index'
import foo from '@/components/foo'
import bar from '@/components/bar'
Vue.use(Router)

export default new Router({
  routes: [
    {
      path: '/',
      name: 'index',
      component: index
    },
    {
      path: '/foo',
      name: 'foo',
      component: foo
    },
    {
      path: '/bar',
      name: 'bar',
      component: bar
    }
  ]
})
```
2. 接下来是定义切换路由的界面
```javascript
// components/index.vue
<template>
  <div class="hello">
    <h1>{{ msg }}</h1>
    <h2>Essential Links</h2>
    <router-link to="/foo" tag="div">
      <a>/foo</a>
    </router-link>
    <router-link to="/bar" tag="div">
      <a>/bar</a>
    </router-link>`
  </div>
</template>

<script>
export default {
  name: 'HelloWorld',
  data () {
    return {
      msg: 'Welcome to Your Vue.js App'
    }
  }
}
</script>
// 可以看到上面使用了 vue-router 自带的路由组件 router-link 和 router-view
```
3. 然后是展示路由渲染结果的页面(主界面)
```javascript
// app.vue
<template>
  <div id="app">
    <img src="./assets/logo.png">
    <router-view/>
  </div>
</template>

<script>
export default {
  name: 'App'
}
</script>
```
4. 最后是在实例化 vue 根组件的时候传入路由对象
```javascript
// main.js
import Vue from 'vue'
import App from './App'
import router from './router'
new Vue({
  el: '#app',
  router,
  components: { App },
  template: '<App/>'
})
```
其主界面运行结果如下图所示:  

![](./images/router-link-view.png)  

从图中对比 app.vue 文件可知。vue-router 将 router-view 替换了首页路径下匹配的组件 components/index.vue， 同时 router-link 被渲染成了包含两个 a 标签的的 div。且 a 链接的地址分别渲染为 #/foo, #/bar,这是因为 vue-router 默认的模式是 hash 模式。

我们来看看 new router 的时候发生了什么
```javascript
export default class VueRouter {
  constructor (options: RouterOptions = {}) {
    this.app = null
    this.apps = []
    this.options = options
    this.beforeHooks = []  // 存储全局前置守卫的回调
    this.resolveHooks = [] // 存储全局解析守卫的回调函数
    this.afterHooks = [] // 存储全局后置守卫的回调
    this.matcher = createMatcher(options.routes || [], this) // 常见路径和组件之间的映射表

    let mode = options.mode || 'hash' // 默认模式为 hash 模式
    this.fallback = mode === 'history' && !supportsPushState && options.fallback !== false // 是否降级
    if (this.fallback) {
      mode = 'hash'
    }
    if (!inBrowser) {
      mode = 'abstract'
    }
    this.mode = mode

    switch (mode) {
      case 'history':
        this.history = new HTML5History(this, options.base)
        break
      case 'hash':
        this.history = new HashHistory(this, options.base, this.fallback)
        break
      case 'abstract':
        this.history = new AbstractHistory(this, options.base)
        break
      default:
        if (process.env.NODE_ENV !== 'production') {
          assert(false, `invalid mode: ${mode}`)
        }
    }
  }

  match (
    raw: RawLocation,
    current?: Route,
    redirectedFrom?: Location
  ): Route {
    return this.matcher.match(raw, current, redirectedFrom)
  }

  get currentRoute (): ?Route {
    return this.history && this.history.current
  }

  beforeEach (fn: Function): Function {
    return registerHook(this.beforeHooks, fn)  // 注册路由前置
  }

  beforeResolve (fn: Function): Function {
    return registerHook(this.resolveHooks, fn)
  }

  afterEach (fn: Function): Function {
    return registerHook(this.afterHooks, fn)
  }

  onReady (cb: Function, errorCb?: Function) {
    this.history.onReady(cb, errorCb)
  }

  onError (errorCb: Function) {
    this.history.onError(errorCb)
  }

  push (location: RawLocation, onComplete?: Function, onAbort?: Function) {
    this.history.push(location, onComplete, onAbort)
  }

  replace (location: RawLocation, onComplete?: Function, onAbort?: Function) {
    this.history.replace(location, onComplete, onAbort)
  }

  go (n: number) {
    this.history.go(n)
  }

  back () {
    this.go(-1)
  }

  forward () {
    this.go(1)
  }

  getMatchedComponents (to?: RawLocation | Route): Array<any> {
    const route: any = to
      ? to.matched
        ? to
        : this.resolve(to).route
      : this.currentRoute
    if (!route) {
      return []
    }
    return [].concat.apply([], route.matched.map(m => {
      return Object.keys(m.components).map(key => {
        return m.components[key]
      })
    }))
  }

  resolve (
    to: RawLocation,
    current?: Route,
    append?: boolean
  ): {
    location: Location,
    route: Route,
    href: string,
    // for backwards compat
    normalizedTo: Location,
    resolved: Route
  } {
    const location = normalizeLocation(
      to,
      current || this.history.current,
      append,
      this
    )
    const route = this.match(location, current)
    const fullPath = route.redirectedFrom || route.fullPath
    const base = this.history.base
    const href = createHref(base, fullPath, this.mode)
    return {
      location,
      route,
      href,
      // for backwards compat
      normalizedTo: location,
      resolved: route
    }
  }

  addRoutes (routes: Array<RouteConfig>) {
    this.matcher.addRoutes(routes)
    if (this.history.current !== START) {
      this.history.transitionTo(this.history.getCurrentLocation())
    }
  }
}

function registerHook (list: Array<any>, fn: Function): Function {
  list.push(fn)
  return () => {
    const i = list.indexOf(fn)
    if (i > -1) list.splice(i, 1)
  }
}

function createHref (base: string, fullPath: string, mode) {
  var path = mode === 'hash' ? '#' + fullPath : fullPath
  return base ? cleanPath(base + '/' + path) : path
}

VueRouter.install = install
VueRouter.version = '__VERSION__'

if (inBrowser && window.Vue) {
  window.Vue.use(VueRouter)
}
```
可以看到，在 vue-router 的构造函数中，主要做了以下的几件事:  
1. 根据传入的 routers 创建一个路由映射器，这个路由映射器的定义如下所示
```javascript
export type Matcher = {
  match: (raw: RawLocation, current?: Route, redirectedFrom?: Location) => Route;
  addRoutes: (routes: Array<RouteConfig>) => void;
};

```
其实就是一个对象，该对象有两个方法，分别是获取路由和添加路由。

2. 初始化各种全局路由钩子
3. 初始化 history 属性

那我们继续来看下，初始化 history 属性的过程，这里我们只看 HashHistory，首先 HashHistory 继承自 History， History 的定义如下所示：  
```javascript
export class History {
  router: Router;
  base: string;
  current: Route;
  pending: ?Route;
  cb: (r: Route) => void;
  ready: boolean;
  readyCbs: Array<Function>;
  readyErrorCbs: Array<Function>;
  errorCbs: Array<Function>;

  // implemented by sub-classes
  +go: (n: number) => void;
  +push: (loc: RawLocation) => void;
  +replace: (loc: RawLocation) => void;
  +ensureURL: (push?: boolean) => void;
  +getCurrentLocation: () => string;

  constructor (router: Router, base: ?string) {
    this.router = router
    this.base = normalizeBase(base)
    // start with a route object that stands for "nowhere"
    this.current = START
    this.pending = null
    this.ready = false
    this.readyCbs = []
    this.readyErrorCbs = []
    this.errorCbs = []
  }

  listen (cb: Function) {
    this.cb = cb
  }

  onReady (cb: Function, errorCb: ?Function) {
    if (this.ready) {
      cb()
    } else {
      this.readyCbs.push(cb)
      if (errorCb) {
        this.readyErrorCbs.push(errorCb)
      }
    }
  }

  onError (errorCb: Function) {
    this.errorCbs.push(errorCb)
  }

  transitionTo (location: RawLocation, onComplete?: Function, onAbort?: Function) {
    const route = this.router.match(location, this.current)
    this.confirmTransition(route, () => {
      this.updateRoute(route)
      onComplete && onComplete(route)
      this.ensureURL()

      // fire ready cbs once
      if (!this.ready) {
        this.ready = true
        this.readyCbs.forEach(cb => { cb(route) })
      }
    }, err => {
      if (onAbort) {
        onAbort(err)
      }
      if (err && !this.ready) {
        this.ready = true
        this.readyErrorCbs.forEach(cb => { cb(err) })
      }
    })
  }

  confirmTransition (route: Route, onComplete: Function, onAbort?: Function) {
    const current = this.current
    const abort = err => {
      if (isError(err)) {
        if (this.errorCbs.length) {
          this.errorCbs.forEach(cb => { cb(err) })
        } else {
          warn(false, 'uncaught error during route navigation:')
          console.error(err)
        }
      }
      onAbort && onAbort(err)
    }
    if (
      isSameRoute(route, current) &&
      // in the case the route map has been dynamically appended to
      route.matched.length === current.matched.length
    ) {
      this.ensureURL()
      return abort()
    }

    const {
      updated,
      deactivated,
      activated
    } = resolveQueue(this.current.matched, route.matched)

    const queue: Array<?NavigationGuard> = [].concat(
      // in-component leave guards
      extractLeaveGuards(deactivated), // 路由级别的守卫
      // global before hooks
      this.router.beforeHooks, // 全局前置路由守卫
      // in-component update hooks
      extractUpdateHooks(updated), // 组件路由更新守卫
      // in-config enter guards
      activated.map(m => m.beforeEnter), //
      // async components
      resolveAsyncComponents(activated)
    )

    this.pending = route
    const iterator = (hook: NavigationGuard, next) => {
      if (this.pending !== route) {
        return abort()
      }
      try {
        hook(route, current, (to: any) => {
          if (to === false || isError(to)) {
            // next(false) -> abort navigation, ensure current URL
            this.ensureURL(true)
            abort(to)
          } else if (
            typeof to === 'string' ||
            (typeof to === 'object' && (
              typeof to.path === 'string' ||
              typeof to.name === 'string'
            ))
          ) {
            // next('/') or next({ path: '/' }) -> redirect
            abort()
            if (typeof to === 'object' && to.replace) {
              this.replace(to)
            } else {
              this.push(to)
            }
          } else {
            // confirm transition and pass on the value
            next(to)
          }
        })
      } catch (e) {
        abort(e)
      }
    }

    runQueue(queue, iterator, () => {
      const postEnterCbs = []
      const isValid = () => this.current === route
      // wait until async components are resolved before
      // extracting in-component enter guards
      const enterGuards = extractEnterGuards(activated, postEnterCbs, isValid)
      const queue = enterGuards.concat(this.router.resolveHooks)
      runQueue(queue, iterator, () => {
        if (this.pending !== route) {
          return abort()
        }
        this.pending = null
        onComplete(route)
        if (this.router.app) {
          this.router.app.$nextTick(() => {
            postEnterCbs.forEach(cb => { cb() })
          })
        }
      })
    })
  }

  updateRoute (route: Route) {
    const prev = this.current
    this.current = route
    this.cb && this.cb(route)
    this.router.afterHooks.forEach(hook => {
      hook && hook(route, prev)
    })
  }
}


function resolveQueue (
  current: Array<RouteRecord>,
  next: Array<RouteRecord>
): {
  updated: Array<RouteRecord>,
  activated: Array<RouteRecord>,
  deactivated: Array<RouteRecord>
} {
  let i
  const max = Math.max(current.length, next.length)
  for (i = 0; i < max; i++) {
    if (current[i] !== next[i]) {
      break
    }
  }
  return {
    updated: next.slice(0, i),
    activated: next.slice(i),
    deactivated: current.slice(i)
  }
}

function extractGuards (
  records: Array<RouteRecord>,
  name: string,
  bind: Function,
  reverse?: boolean
): Array<?Function> {
  const guards = flatMapComponents(records, (def, instance, match, key) => {
    const guard = extractGuard(def, name)
    if (guard) {
      return Array.isArray(guard)
        ? guard.map(guard => bind(guard, instance, match, key))
        : bind(guard, instance, match, key)
    }
  })
  return flatten(reverse ? guards.reverse() : guards)
}

function extractGuard (
  def: Object | Function,
  key: string
): NavigationGuard | Array<NavigationGuard> {
  if (typeof def !== 'function') {
    // extend now so that global mixins are applied.
    def = _Vue.extend(def)
  }
  return def.options[key]
}

function extractLeaveGuards (deactivated: Array<RouteRecord>): Array<?Function> {
  return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true)
}

function extractUpdateHooks (updated: Array<RouteRecord>): Array<?Function> {
  return extractGuards(updated, 'beforeRouteUpdate', bindGuard)
}

function bindGuard (guard: NavigationGuard, instance: ?_Vue): ?NavigationGuard {
  if (instance) {
    return function boundRouteGuard () {
      return guard.apply(instance, arguments)
    }
  }
}

function extractEnterGuards (
  activated: Array<RouteRecord>,
  cbs: Array<Function>,
  isValid: () => boolean
): Array<?Function> {
  return extractGuards(activated, 'beforeRouteEnter', (guard, _, match, key) => {
    return bindEnterGuard(guard, match, key, cbs, isValid)
  })
}

function bindEnterGuard (
  guard: NavigationGuard,
  match: RouteRecord,
  key: string,
  cbs: Array<Function>,
  isValid: () => boolean
): NavigationGuard {
  return function routeEnterGuard (to, from, next) {
    return guard(to, from, cb => {
      next(cb)
      if (typeof cb === 'function') {
        cbs.push(() => {
          // #750
          // if a router-view is wrapped with an out-in transition,
          // the instance may not have been registered at this time.
          // we will need to poll for registration until current route
          // is no longer valid.
          poll(cb, match.instances, key, isValid)
        })
      }
    })
  }
}

function poll (
  cb: any, // somehow flow cannot infer this is a function
  instances: Object,
  key: string,
  isValid: () => boolean
) {
  if (instances[key]) {
    cb(instances[key])
  } else if (isValid()) {
    setTimeout(() => {
      poll(cb, instances, key, isValid)
    }, 16)
  }
}
```

一些定义
```javascript
export interface Location {
  name?: string;
  path?: string;
  hash?: string;
  query?: Dictionary<string | string[]>;
  params?: Dictionary<string>;
  append?: boolean;
  replace?: boolean;
}

export interface Route {
  path: string;
  name?: string;
  hash: string;
  query: Dictionary<string | string[]>;
  params: Dictionary<string>;
  fullPath: string;
  matched: RouteRecord[];
  redirectedFrom?: string;
  meta?: any;
}

export interface RouteRecord {
  path: string;
  regex: RegExp;
  components: Dictionary<Component>;
  instances: Dictionary<Vue>;
  name?: string;
  parent?: RouteRecord;
  redirect?: RedirectOption;
  matchAs?: string;
  meta: any;
  beforeEnter?: (
    route: Route,
    redirect: (location: RawLocation) => void,
    next: () => void
  ) => any;
  props: boolean | Object | RoutePropsFunction | Dictionary<boolean | Object | RoutePropsFunction>;
}
```


接下来我们看看 router-link 的实现
``` javascript
export default {
  name: 'RouterLink',
  props: {
    to: {
      type: toTypes,
      required: true
    },
    tag: {
      type: String,
      default: 'a'
    },
    exact: Boolean,
    append: Boolean,
    replace: Boolean,
    event: {
      type: eventTypes,
      default: 'click'
    }
  },
  render (h: Function) {
    const router = this.$router
    const current = this.$route
    const { location, route, href } = router.resolve(this.to, current, this.append)

    const handler = e => {
      if (guardEvent(e)) {
        if (this.replace) {
          router.replace(location)
        } else {
          router.push(location)
        }
      }
    }

    const on = { click: guardEvent }
    if (Array.isArray(this.event)) {
      this.event.forEach(e => { on[e] = handler })
    } else {
      on[this.event] = handler
    }

    const data: any = {
      class: classes
    }
    
    if (this.tag === 'a') {
      // 如果是要渲染成 a 标签, 则将事件监听和目标地址都保存在 data 属性里面
      data.on = on
      data.attrs = { href }
    } else {
      // find the first <a> child and apply listener and href
      const a = findAnchor(this.$slots.default) // 找到 router-link 包含的标签
      if (a) {
        // in case the <a> is a static node
        // 将事件和目标连接绑定到 a 标签上
        a.isStatic = false
        const aData = a.data = extend({}, a.data)
        aData.on = on
        const aAttrs = a.data.attrs = extend({}, a.data.attrs)
        aAttrs.href = href
      } else {
        // doesn't have <a> child, apply listener to self
        data.on = on 
      }
    }
    // 渲染
    return h(this.tag, data, this.$slots.default)
  }
}

function guardEvent (e) {
  // don't redirect with control keys 不处理键盘事件
  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) return
  // don't redirect when preventDefault called
  if (e.defaultPrevented) return
  // don't redirect on right click
  if (e.button !== undefined && e.button !== 0) return // 不处理鼠标右键
  // don't redirect if `target="_blank"`
  if (e.currentTarget && e.currentTarget.getAttribute) {
    const target = e.currentTarget.getAttribute('target')
    if (/\b_blank\b/i.test(target)) return
  }
  // this may be a Weex event which doesn't have this method
  if (e.preventDefault) {
    e.preventDefault()
  }
  return true
}

function findAnchor (children) {
  if (children) {
    let child
    for (let i = 0; i < children.length; i++) {
      child = children[i]
      if (child.tag === 'a') {
        return child
      }
      if (child.children && (child = findAnchor(child.children))) {
        return child
      }
    }
  }
}
```
从上面可以看出， router-link 是一个函数式组件，其重要的作用的处理了事件的绑定处理，将组件内的事件和属性传递到 a 标签中。















